# Lab 5

## Lab 05-01

### 1. What is the address of DllMain?


DllMain is found at 0x1000D02E in the .text section

![DllMain location](lab05_01_dll_DllMain_location.png)

<br/><br/>

### 2. Use the Imports window to browse to gethostbyname. Where is the import located?

the gethostbyname imports can be found at 0x100163CC in the .idata section

![gethostbyname import's location](lab05_01_dll_gethostbyname_location.png)

<br/><br/>

### 3. How many functions call gethostbyname?

gethostbyname is called by 9 functions 

![gethostbyname call count](lab05_01_dll_gethostbyname_usage_count.png)

<br/><br/>

### 4. Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?

The DNS request performed will reach out to pics.practicalmalwareanalysis.com

![gethostbyname querying a domain name](lab05_01_dll_get_DNS_request_url.png)

![The domain name requested](lab05_01_dll_get_DNS_request_url_2.png)

<br/><br/>

### 5. How many local variables has IDA Pro recognized for the subroutine at 0x10001656?

20 local variables is recognized by IDA at sub_10001656

<br/><br/>

### 6. How many parameters has IDA Pro recognized for the subroutine at 0x10001656?

1 parameter is recognized by IDA at sub_10001656.

![Local variables and arguments initialization recognized by IDA in sub_10001656](lab05_01_dll_local_variable.png)

<br/><br/>

### 7. Use the Strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?

At 0x10095B34 in the xdoors_d section

![Location of the string "\cmd.exe" in the program](lab05_01_dll_strings_rce_location.png)

<br/><br/>

### 8. What is happening in the area of code that references \cmd.exe /c?

looking into the functiohn code that has the cmd.exe string, we can see that there's alot of comparison happening in the assembly code. This is probably condition checking on the input accepted by the malware. The string comparison includes comparing them with "uptime", "install", "cd", "inject". The function also consists some strings that shows that the malware is a reverse shell program. Finally, the function also use  multiple send and recv function which are involved in communicating with a server. These evidence shows that this is a remote reverse shell session function. 

![Many Suspicious string comparison](lab05_01_dll_reverse_shell_operations.png)

![Many network socket send and recv function call](lab05_01_dll_reverse_shell_send_recv.png)

![Suspicious message claiming the program to be a Remote Shell Session](lab05_01_dll_reverse_shell_string.png)

<br/><br/>

### 9. In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4â€™s cross-references.)

Checking the usage of dword_1008E5C4 in the file, we can see that the value of dword_1008E5C4 is changed at 0x10001678, which involve moving the EAX value register value into dword_1008E5C4. Now, to figure out how we got the EAX value, we need to look into the previous subroutine call  sub_10003695. This is because EAX will contain the return value of a subroutine call. In the subroutine, we can see that a call to GetVersionEx, which contains the version of the machine operating system. The dwPlatformId member of OSVERSIONINFOA (returned from initializing GetVersionExA while using a OSVERSIONINFO structure as the parameter) will return the value 2 if the Operating System operating the program is using older Windows OS such as Win XP, Win7, Win Vista, etc (Full list can be viewed in microsoft documentation[^1]). If dwPlatformId returned '2' as its value, then the 'cmp' instruction will result in setting the AL register value to 1. Which will in turn, make dword_1008E5C4's value to be 1.


![Usage of dword_1008E5C4 in the program](lab05_01_dll_dword_1008E5C4_usage.png)

![Only one usage of dword_1008E5C4 involves in changing its content](lab05_01_dll_dword_1008E5C4_value_change.png)

![subroutine sub_10003695](lab05_01_dll_dword_1008E5C4_how_eax_is_obtained.png)
inlinekeyboard
![Use of dwPlatformId from microsoft documentation](lab05_01_dll_dword_1008E5C4_OS_version_checking.png)

<br/><br/>

### 10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?

In the subroutine 0x1000FF58 there are a lot of memcmp function call, and at loc_10010468 the "robotwork" memcmp function call is at 0x10010452. If the memcmp returns 0 (if the string matches "robotwork"), the jnz instruction will not be executed. If that's the case, the sub_100052A2 subroutine will be called. In this subroutine, the HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion registry key is opened and two registry value is requested, namely "WorkTime" and "WorkTimes". Then, the information is sent to the network socket opened up previously in subroutine sub_100038EE.

![0x1000FF58 subroutine](lab05_01_dll_0x1000FF58_subroutine.png)

![0x1000FF58 subroutine robotwork string comparison location](lab05_01_dll_0x1000FF58_robotwork.png)

![Executing sub_100052A2 subroutine when the string is "robotwork"](lab05_01_dll_0x1000FF58_if_memcmp_0.png)

![Subroutine sub_100052A2 opening the "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion" registry key](lab05_01_dll_sub_100052A2.png)

![Subroutine sub_100052A2 querying for the WorkTime registry value](lab05_01_dll_sub_100052A2_reg_value.png)

![Subroutine sub_100052A2 querying for the WorkTimes registry value](lab05_01_dll_sub_100052A2_reg_value_2.png)

![Sending the information retrieved from the registry to network the connected socket](lab05_01_dll_sub_100052A2_sub_100038EE.png)

![Sending the information retrieved from the registry to network the connected socket](lab05_01_dll_sub_100052A2_sub_100038EE_send_info_to_socket.png)

<br/><br/>

### 11. What does the export PSLIST do?

The PSLIST export is located at 0x10007025. Going to that address, we can see that the function will call the subroutine sub_100036C3 to perform some checking. Going into sub_100036C3, we can see that it is actually another subroutine which resembles the previous subroutine, sub_10003695. Other than checking for the OS version of the system, sub_100036C3 will perform another check with the dwMajorVersion member of OSVERSIONINFOA. dwMajorVersion contains the major version number of the Windows OS. At the cmp instruction, we can see that the program is comparing dwMajorVersion's value with 5. If dwMajorVersion returns the value 5, it means that the OS of the system is either Windows Server 2003 R2, Windows Server 2003, Windows XP, or Windows 2000. This all is basically checking if the program suitable for the OS or not, if not the export will not do anything further.

Let's say that the OS is suitable for the operation. The OS detection subroutine will return 1 to EAX. Two paths will be available for th export function. Both of them utilized CreateToolhelp32Snapshot to list out every processes currently running on the system. However, only one of them will send the process listing over the socket. The usage of CreateToolhelp32Snapshot also explains the extra checks done in sub_100036C3, as only Windows XP and Windows Server 2003 support this library. More information can be read on Microsoft documentation[^2].

![PSLIST location](lab05_01_dll_PSLIST_location.png)

![PSLIST export content](lab05_01_dll_PSLIST_content.png)

![sub_100036C3 checking for OS version of the device](lab05_01_dll_PSLIST_sub_100036C3.png)

![Use of dwMajorVersion in a program](lab05_01_dll_PSLIST_use_of_dwMajorVersion.png)

![Reason why dwMajorVersion is needed](lab05_01_dll_PSLIST_CreateToolhelp32Snapshot_requirements.png)

<br/><br/>

### 12. Use the graph mode to graph the cross-references from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?

By looking into the graph that shows the cross-references from sub_10004E79, we can see that the function will calls GetSystemDefaultLangID as well as send. It is very likely that the function is meant to send the system language identifier[^3] over the network socket. While for te new function name, we can name it send_language_ID. 

![sub_10004E79's content](lab05_01_dll_sub_10004E79_content.png)

![cross references from sub_10004E79](lab05_01_dll_sub_10004E79_cross_references_from.png)

<br/><br/>

### 13. How many Windows API functions does DllMain call directly? How many at a depth of 2?

When looking into the functions that DllMain will call at the depth of 1 and 2, we can see that DllMain would call CreateThread, strncpy, strlen and strnicmp directly (depth of 1). Then, going further down to depth 2, we can see that the graphs is much bigger and it's impossible to put them all into a single picture. But, we can see that there's many call to networking function like gethostbyname, WinExec, Sleep and closesocket, etc. 

![depth 1 of functions that DllMain will call](lab05_01_dll_DllMain_xref_chart_depth_1.png)

![depth 2 of functions that DllMain will call](lab05_01_dll_DllMain_xref_chart_depth_2.png)

![depth 2 of functions that DllMain will call](lab05_01_dll_DllMain_xref_chart_depth_2_networking_functions.png)

<br/><br/>

### 14. At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?

looking at the assembly code above the Sleep function call, we can see that the value of eax is multiplied by the value 3E8h. The value 3E8h is in hexadecimal format, when converted to decimal the value of this number is 1000. Then, moving up a little more in the code, we can see that the 0Dh value is added into eax. Again, the value is in hexadecimal and converting it to decimal would result in it being 13. We can also see that beforethe addition, the EAX value is changed by the off_10019020. Clicking into the constant will navigate us to the value it's currently pointing to. The string is "[This is CTI]30". By adding 13 into the offset will cause EAX to point to 30. Calling atoi will cause EAX to have the value of the offset pointed by it previously. Finally, by calculating the multiplication we'll see that the sleeping time is 30000 milliseconds (30 secs)

![How long would the sleep function call at 0x10001358 sleep](lab05_01_dll_Sleep_function_call.png)

![value of 3E8 in Decimal](lab05_01_dll_Sleep_function_call_3E8_value.png)

<br/><br/>

### 15. At 0x10001701 is a call to socket. What are the three parameters?


### 16. Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful? What are the parameters after you apply changes?


### 17. Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?


### 18. Jump your cursor to 0x1001D988. What do you find?


### 19. If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988.) What happens after you run the script?


### 20. With the cursor in the same location, how do you turn this data into a single ASCII string?


### 21. Open the script with a text editor. How does it work?



[^1]: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoa
[^2]: https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot
[^3]: https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getsystemdefaultlangid